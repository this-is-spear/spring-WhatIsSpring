## 스프링을 이용해 의존성 주입을 할 수 있을까?
나는 의존성 주입을 공부하기 전에 DI라는 단어를 들었을 때, 단순히 Dependency의 약자인 줄 알아서 pom.xml에 존재하는 의존성 주입을 말하는 줄 알았다. 그래서 스프링이 직접 해주는 의존성 주입은 이 파일에 있는 게 전부인 줄 알았지만 그게 아니었다. 내가 직접 스프링 컨테이너에 스프링 빈을 등록해 의존성 주입을 할 수 있다는 것을 처음 알수 있었다.


### 방금까지 공부했던 AppConfig를 이용해 의존성 주입한 게 다가 아닌가?

저번 공부까지 나는 AppConfig 클래스를 이용해 외부에서 의존성 주입을 하는 공부를 했고, 방금까지 자바를 이용해 의존성 주입에 대한 공부를 했다. 자바를 이용해 의존성 주입을 할 수 있지만 스프링 컨테이너에 등록하지 않고 사용하는 방법을 이용했다.

하지만 스프링을 이용해 SOLID 원칙을 잘 적용할 수 있다고 얘길 들었으니 직접 사용해볼 생각이다.

### 스프링 빈을 사용하면 좋은 장점


#### 더 복잡하게 빈을 등록하는 이유가 무엇일까?

나는 조금 더 고민해볼 필요가 있다고 생각하여 아직 작성하지 않았다.

### 스프링을 이용해 의존성 주입을 하는 방법

1.  @ComponentScan  
    @SpringBootApplication 어노테이션에는 @ComponentScan 어노테이션이 설정되어 있다.

**@ComponentScan 어노테이션이 붙은 클래스가 있는 패키지부터 모든 하위 패키지의 클래스 모두** 탐색하면서 @Component 어노테이션이 붙은 클래스들을 빈으로 등록한다.

우리가 흔히 사용하는 @Service, @Controller, @Repository 등, 모두 @Component 어노테이션을 내부적으로 사용하고 있어서 자동으로 빈으로 등록이 된다.

2.  @Configuration  
    @Configuration 어노테이션에도 @Component 어노테이션을 사용하고 있기 때문에, @ComponentScan 어노테이션의 스캔 대상이 되고, @SpringBootTest 어노테이션이 붙은 클래스가 실행이 될 때, 자동으로 빈으로 등록이 된다.

클래스에 @Configuration 어노테이션을 사용해 이 클래스는 구성 정보가 들어 있는 클래스라는 표시를 해두면,  
스프링은 @Configuration 안의 @Bean이라는 어노테이션을 찾아 스프링 컨테이너에 등록한다.

#### AppConfig 클래스를 스프링 컨테이너로 만들기

현재까지 AppConfig 클래스를 사용해서 직접 객체를 생성하고 의존성 주입을 했지만, 이제부터는 스프링 컨테이너를 통해 사용한다.  
스프링 컨테이너는 @Configuration 어노테이션이 붙은 AppConfig 클래스를 설정 정보로 사용한다.

@Configuration 어노테이션을 이용해 스프링 컨테이너로 만들고 @Bean 어노테이션을 사용해 스프링 컨테이너에 등록을 한다.  
여기서 @Bean 어노테이션이 적힌 메서드를 모두 호출해서 반환된 객체를 스프링 컨테이너에 등록한다. 이렇게 스프링 컨테이너에 등록된 객체를 스프링 빈이라 한다.

### 사용하는 방법

테스트에서 스프링 컨테이너에 등록된 빈을 사용하기 위해 스프링 컨테이너인 ApplicationContext를 구현한 AnnotationConfigApplicationContext 클래스를 사용해  
AppConfig 클래스를 스프링 빈으로 만든 후, 스프링 컨테이너에 등록했다.

> 테스트가 아닌 실제 환경은 @SpringBootApplication에서는 @ComponentScan 어노테이션 덕분에 @Configuration 어노테이션을 사용한 AppConfig 클래스를 빈으로 등록해주지만, 단위 테스트에서는 @ComponentScan 어노테이션 등, @Configuration 어노테이션을 인식할 수 없다.